//! Migration file writer.
//!
//! This module generates Rust source files for migrations.

use std::path::Path;

use crate::error::Result;
use crate::operations::MigrationOperation;
use crate::schema::{ColumnSchema, DefaultValue, ForeignKeyAction, SqlType};

/// Generates migration file content.
#[derive(Debug, Default)]
pub struct MigrationWriter {
    /// Application/module name.
    app: String,
    /// Migration name.
    name: String,
    /// Dependencies.
    dependencies: Vec<(String, String)>,
    /// Operations.
    operations: Vec<MigrationOperation>,
}

impl MigrationWriter {
    /// Creates a new migration writer.
    #[must_use]
    pub fn new(app: impl Into<String>, name: impl Into<String>) -> Self {
        Self {
            app: app.into(),
            name: name.into(),
            dependencies: Vec::new(),
            operations: Vec::new(),
        }
    }

    /// Adds a dependency.
    #[must_use]
    pub fn depends_on(mut self, app: impl Into<String>, name: impl Into<String>) -> Self {
        self.dependencies.push((app.into(), name.into()));
        self
    }

    /// Adds an operation.
    #[must_use]
    pub fn operation(mut self, op: MigrationOperation) -> Self {
        self.operations.push(op);
        self
    }

    /// Adds multiple operations.
    #[must_use]
    pub fn operations(mut self, ops: Vec<MigrationOperation>) -> Self {
        self.operations.extend(ops);
        self
    }

    /// Generates the Rust source code for the migration file.
    #[must_use]
    pub fn generate(&self) -> String {
        let mut code = String::new();

        // Header comment
        code.push_str(&format!("//! Migration: {}/{}\n", self.app, self.name));
        code.push_str("//!\n");
        code.push_str("//! This file was auto-generated by oxide-migrate.\n");
        code.push_str("//! Do not edit manually unless you know what you're doing.\n\n");

        // Imports
        code.push_str("use oxide_migrate::prelude::*;\n\n");

        // Struct definition
        code.push_str("pub struct Migration;\n\n");

        // Trait implementation
        code.push_str("impl OxideMigration for Migration {\n");

        // APP constant
        code.push_str(&format!(
            "    const APP: &'static str = \"{}\";\n",
            self.app
        ));

        // NAME constant
        code.push_str(&format!(
            "    const NAME: &'static str = \"{}\";\n",
            self.name
        ));

        // DEPENDENCIES constant
        code.push_str("    const DEPENDENCIES: &'static [(&'static str, &'static str)] = &[\n");
        for (dep_app, dep_name) in &self.dependencies {
            code.push_str(&format!("        (\"{}\", \"{}\"),\n", dep_app, dep_name));
        }
        code.push_str("    ];\n\n");

        // operations() method
        code.push_str("    fn operations() -> Vec<MigrationOperation> {\n");
        code.push_str("        vec![\n");

        for op in &self.operations {
            code.push_str(&self.operation_to_code(op, 12));
            code.push_str(",\n");
        }

        code.push_str("        ]\n");
        code.push_str("    }\n");
        code.push_str("}\n");

        code
    }

    /// Converts an operation to Rust code.
    fn operation_to_code(&self, op: &MigrationOperation, indent: usize) -> String {
        let indent_str = " ".repeat(indent);

        match op {
            MigrationOperation::CreateTable {
                name,
                columns,
                primary_key,
                if_not_exists,
            } => {
                let mut code = format!("{}MigrationOperation::CreateTable {{\n", indent_str);
                code.push_str(&format!(
                    "{}    name: \"{}\".to_string(),\n",
                    indent_str, name
                ));
                code.push_str(&format!("{}    columns: vec![\n", indent_str));
                for col in columns {
                    code.push_str(&self.column_to_code(col, indent + 8));
                    code.push_str(",\n");
                }
                code.push_str(&format!("{}    ],\n", indent_str));
                code.push_str(&format!(
                    "{}    primary_key: vec![{}],\n",
                    indent_str,
                    primary_key
                        .iter()
                        .map(|s| format!("\"{}\".to_string()", s))
                        .collect::<Vec<_>>()
                        .join(", ")
                ));
                code.push_str(&format!(
                    "{}    if_not_exists: {},\n",
                    indent_str, if_not_exists
                ));
                code.push_str(&format!("{}}}", indent_str));
                code
            }

            MigrationOperation::DropTable { name, if_exists } => {
                format!(
                    "{}MigrationOperation::DropTable {{ name: \"{}\".to_string(), if_exists: {} }}",
                    indent_str, name, if_exists
                )
            }

            MigrationOperation::RenameTable { old_name, new_name } => {
                format!(
                    "{}MigrationOperation::rename_table(\"{}\", \"{}\")",
                    indent_str, old_name, new_name
                )
            }

            MigrationOperation::AddColumn { table, column } => {
                let mut code = format!("{}MigrationOperation::AddColumn {{\n", indent_str);
                code.push_str(&format!(
                    "{}    table: \"{}\".to_string(),\n",
                    indent_str, table
                ));
                code.push_str(&format!("{}    column: ", indent_str));
                code.push_str(&self.column_to_code(column, 0));
                code.push_str(",\n");
                code.push_str(&format!("{}}}", indent_str));
                code
            }

            MigrationOperation::DropColumn { table, column_name } => {
                format!(
                    "{}MigrationOperation::drop_column(\"{}\", \"{}\")",
                    indent_str, table, column_name
                )
            }

            MigrationOperation::RenameColumn {
                table,
                old_name,
                new_name,
            } => {
                format!(
                    "{}MigrationOperation::rename_column(\"{}\", \"{}\", \"{}\")",
                    indent_str, table, old_name, new_name
                )
            }

            MigrationOperation::AlterColumn {
                table,
                column_name,
                changes,
                original,
            } => {
                let mut code = format!("{}MigrationOperation::AlterColumn {{\n", indent_str);
                code.push_str(&format!(
                    "{}    table: \"{}\".to_string(),\n",
                    indent_str, table
                ));
                code.push_str(&format!(
                    "{}    column_name: \"{}\".to_string(),\n",
                    indent_str, column_name
                ));
                code.push_str(&format!("{}    changes: ColumnChanges {{\n", indent_str));

                if let Some(ref sql_type) = changes.sql_type {
                    code.push_str(&format!(
                        "{}        sql_type: Some({}),\n",
                        indent_str,
                        self.sql_type_to_code(sql_type)
                    ));
                } else {
                    code.push_str(&format!("{}        sql_type: None,\n", indent_str));
                }

                if let Some(nullable) = changes.nullable {
                    code.push_str(&format!(
                        "{}        nullable: Some({}),\n",
                        indent_str, nullable
                    ));
                } else {
                    code.push_str(&format!("{}        nullable: None,\n", indent_str));
                }

                if let Some(ref default) = changes.default {
                    code.push_str(&format!(
                        "{}        default: Some({}),\n",
                        indent_str,
                        self.default_value_to_code(default)
                    ));
                } else {
                    code.push_str(&format!("{}        default: None,\n", indent_str));
                }

                if let Some(unique) = changes.unique {
                    code.push_str(&format!(
                        "{}        unique: Some({}),\n",
                        indent_str, unique
                    ));
                } else {
                    code.push_str(&format!("{}        unique: None,\n", indent_str));
                }

                code.push_str(&format!("{}    }},\n", indent_str));

                if let Some(orig) = original {
                    code.push_str(&format!("{}    original: Some(", indent_str));
                    code.push_str(&self.column_to_code(orig, 0));
                    code.push_str("),\n");
                } else {
                    code.push_str(&format!("{}    original: None,\n", indent_str));
                }

                code.push_str(&format!("{}}}", indent_str));
                code
            }

            MigrationOperation::CreateIndex {
                name,
                table,
                columns,
                unique,
                condition,
                if_not_exists,
            } => {
                let mut code = format!("{}MigrationOperation::CreateIndex {{\n", indent_str);
                code.push_str(&format!(
                    "{}    name: \"{}\".to_string(),\n",
                    indent_str, name
                ));
                code.push_str(&format!(
                    "{}    table: \"{}\".to_string(),\n",
                    indent_str, table
                ));
                code.push_str(&format!(
                    "{}    columns: vec![{}],\n",
                    indent_str,
                    columns
                        .iter()
                        .map(|s| format!("\"{}\".to_string()", s))
                        .collect::<Vec<_>>()
                        .join(", ")
                ));
                code.push_str(&format!("{}    unique: {},\n", indent_str, unique));
                if let Some(cond) = condition {
                    code.push_str(&format!(
                        "{}    condition: Some(\"{}\".to_string()),\n",
                        indent_str, cond
                    ));
                } else {
                    code.push_str(&format!("{}    condition: None,\n", indent_str));
                }
                code.push_str(&format!(
                    "{}    if_not_exists: {},\n",
                    indent_str, if_not_exists
                ));
                code.push_str(&format!("{}}}", indent_str));
                code
            }

            MigrationOperation::DropIndex {
                name,
                table,
                if_exists,
            } => {
                let table_str = table
                    .as_ref()
                    .map(|t| format!("Some(\"{}\".to_string())", t))
                    .unwrap_or_else(|| "None".to_string());
                format!(
                    "{}MigrationOperation::DropIndex {{ name: \"{}\".to_string(), table: {}, if_exists: {} }}",
                    indent_str, name, table_str, if_exists
                )
            }

            MigrationOperation::AddForeignKey { table, foreign_key } => {
                let mut code = format!("{}MigrationOperation::AddForeignKey {{\n", indent_str);
                code.push_str(&format!(
                    "{}    table: \"{}\".to_string(),\n",
                    indent_str, table
                ));
                code.push_str(&format!(
                    "{}    foreign_key: ForeignKeySchema {{\n",
                    indent_str
                ));
                code.push_str(&format!(
                    "{}        name: \"{}\".to_string(),\n",
                    indent_str, foreign_key.name
                ));
                code.push_str(&format!(
                    "{}        columns: vec![{}],\n",
                    indent_str,
                    foreign_key
                        .columns
                        .iter()
                        .map(|s| format!("\"{}\".to_string()", s))
                        .collect::<Vec<_>>()
                        .join(", ")
                ));
                code.push_str(&format!(
                    "{}        references_table: \"{}\".to_string(),\n",
                    indent_str, foreign_key.references_table
                ));
                code.push_str(&format!(
                    "{}        references_columns: vec![{}],\n",
                    indent_str,
                    foreign_key
                        .references_columns
                        .iter()
                        .map(|s| format!("\"{}\".to_string()", s))
                        .collect::<Vec<_>>()
                        .join(", ")
                ));
                code.push_str(&format!(
                    "{}        on_delete: {},\n",
                    indent_str,
                    self.foreign_key_action_to_code(&foreign_key.on_delete)
                ));
                code.push_str(&format!(
                    "{}        on_update: {},\n",
                    indent_str,
                    self.foreign_key_action_to_code(&foreign_key.on_update)
                ));
                code.push_str(&format!("{}    }},\n", indent_str));
                code.push_str(&format!("{}}}", indent_str));
                code
            }

            MigrationOperation::DropForeignKey {
                table,
                constraint_name,
            } => {
                format!(
                    "{}MigrationOperation::drop_foreign_key(\"{}\", \"{}\")",
                    indent_str, table, constraint_name
                )
            }

            MigrationOperation::AddUniqueConstraint {
                table,
                name,
                columns,
            } => {
                format!(
                    "{}MigrationOperation::add_unique_constraint(\"{}\", \"{}\", vec![{}])",
                    indent_str,
                    table,
                    name,
                    columns
                        .iter()
                        .map(|s| format!("\"{}\".to_string()", s))
                        .collect::<Vec<_>>()
                        .join(", ")
                )
            }

            MigrationOperation::DropUniqueConstraint { table, name } => {
                format!(
                    "{}MigrationOperation::drop_unique_constraint(\"{}\", \"{}\")",
                    indent_str, table, name
                )
            }

            MigrationOperation::RunSql { forward, backward } => {
                let backward_str = backward
                    .as_ref()
                    .map(|s| format!("Some(\"{}\".to_string())", s.replace('"', "\\\"")))
                    .unwrap_or_else(|| "None".to_string());
                format!(
                    "{}MigrationOperation::run_sql(\"{}\", {})",
                    indent_str,
                    forward.replace('"', "\\\""),
                    backward_str
                )
            }
        }
    }

    /// Converts a column schema to Rust code.
    fn column_to_code(&self, col: &ColumnSchema, indent: usize) -> String {
        let indent_str = " ".repeat(indent);
        let mut code = format!(
            "{}ColumnSchema::new(\"{}\", {})",
            indent_str,
            col.name,
            self.sql_type_to_code(&col.sql_type)
        );

        if col.primary_key {
            code.push_str(".primary_key()");
        }
        if col.auto_increment {
            code.push_str(".auto_increment()");
        }
        if !col.nullable && !col.primary_key {
            code.push_str(".not_null()");
        }
        if col.unique && !col.primary_key {
            code.push_str(".unique()");
        }
        if col.default != DefaultValue::None {
            code.push_str(&format!(
                ".default({})",
                self.default_value_to_code(&col.default)
            ));
        }
        if let Some(ref check) = col.check {
            code.push_str(&format!(".check(\"{}\")", check.replace('"', "\\\"")));
        }

        code
    }

    /// Converts an SQL type to Rust code.
    fn sql_type_to_code(&self, sql_type: &SqlType) -> String {
        match sql_type {
            SqlType::Integer => "SqlType::Integer".to_string(),
            SqlType::BigInt => "SqlType::BigInt".to_string(),
            SqlType::SmallInt => "SqlType::SmallInt".to_string(),
            SqlType::Text => "SqlType::Text".to_string(),
            SqlType::Varchar(len) => format!("SqlType::Varchar({})", len),
            SqlType::Char(len) => format!("SqlType::Char({})", len),
            SqlType::Boolean => "SqlType::Boolean".to_string(),
            SqlType::DateTime => "SqlType::DateTime".to_string(),
            SqlType::Date => "SqlType::Date".to_string(),
            SqlType::Time => "SqlType::Time".to_string(),
            SqlType::Timestamp => "SqlType::Timestamp".to_string(),
            SqlType::Real => "SqlType::Real".to_string(),
            SqlType::Double => "SqlType::Double".to_string(),
            SqlType::Decimal(p, s) => format!("SqlType::Decimal({}, {})", p, s),
            SqlType::Numeric(p, s) => format!("SqlType::Numeric({}, {})", p, s),
            SqlType::Blob => "SqlType::Blob".to_string(),
            SqlType::Binary(len) => format!("SqlType::Binary({})", len),
            SqlType::VarBinary(len) => format!("SqlType::VarBinary({})", len),
            SqlType::Json => "SqlType::Json".to_string(),
            SqlType::Uuid => "SqlType::Uuid".to_string(),
        }
    }

    /// Converts a default value to Rust code.
    fn default_value_to_code(&self, default: &DefaultValue) -> String {
        match default {
            DefaultValue::None => "DefaultValue::None".to_string(),
            DefaultValue::Null => "DefaultValue::Null".to_string(),
            DefaultValue::Bool(b) => format!("DefaultValue::Bool({})", b),
            DefaultValue::Integer(i) => format!("DefaultValue::Integer({})", i),
            DefaultValue::Float(f) => format!("DefaultValue::Float({})", f),
            DefaultValue::String(s) => {
                format!(
                    "DefaultValue::String(\"{}\".to_string())",
                    s.replace('"', "\\\"")
                )
            }
            DefaultValue::Expression(expr) => {
                format!(
                    "DefaultValue::Expression(\"{}\".to_string())",
                    expr.replace('"', "\\\"")
                )
            }
        }
    }

    /// Converts a foreign key action to Rust code.
    fn foreign_key_action_to_code(&self, action: &ForeignKeyAction) -> &'static str {
        match action {
            ForeignKeyAction::NoAction => "ForeignKeyAction::NoAction",
            ForeignKeyAction::Restrict => "ForeignKeyAction::Restrict",
            ForeignKeyAction::Cascade => "ForeignKeyAction::Cascade",
            ForeignKeyAction::SetNull => "ForeignKeyAction::SetNull",
            ForeignKeyAction::SetDefault => "ForeignKeyAction::SetDefault",
        }
    }

    /// Writes the migration to a file.
    pub fn write_to_file(&self, path: &Path) -> Result<()> {
        let content = self.generate();
        std::fs::write(path, content)?;
        Ok(())
    }
}

/// Generates a migration name from a number and description.
#[must_use]
pub fn generate_migration_name(number: u32, description: &str) -> String {
    let slug: String = description
        .to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { '_' })
        .collect::<String>()
        .trim_matches('_')
        .to_string();

    // Collapse multiple underscores
    let mut result = String::new();
    let mut prev_underscore = false;
    for c in slug.chars() {
        if c == '_' {
            if !prev_underscore {
                result.push(c);
            }
            prev_underscore = true;
        } else {
            result.push(c);
            prev_underscore = false;
        }
    }

    format!("{:04}_{}", number, result)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_migration_name() {
        assert_eq!(generate_migration_name(1, "initial"), "0001_initial");
        assert_eq!(generate_migration_name(2, "add email"), "0002_add_email");
        assert_eq!(
            generate_migration_name(10, "Create Users Table"),
            "0010_create_users_table"
        );
    }

    #[test]
    fn test_generate_simple_migration() {
        let writer = MigrationWriter::new("users", "0001_initial").operation(
            MigrationOperation::create_table(
                "users",
                vec![
                    ColumnSchema::new("id", SqlType::BigInt)
                        .primary_key()
                        .auto_increment(),
                    ColumnSchema::new("name", SqlType::Varchar(255)).not_null(),
                ],
                vec!["id".to_string()],
            ),
        );

        let code = writer.generate();

        assert!(code.contains("pub struct Migration;"));
        assert!(code.contains("impl OxideMigration for Migration"));
        assert!(code.contains("const APP: &'static str = \"users\""));
        assert!(code.contains("const NAME: &'static str = \"0001_initial\""));
        assert!(code.contains("MigrationOperation::CreateTable"));
        assert!(code.contains("ColumnSchema::new(\"id\", SqlType::BigInt)"));
    }

    #[test]
    fn test_generate_with_dependencies() {
        let writer = MigrationWriter::new("users", "0002_add_email")
            .depends_on("users", "0001_initial")
            .operation(MigrationOperation::add_column(
                "users",
                ColumnSchema::new("email", SqlType::Varchar(255)),
            ));

        let code = writer.generate();

        assert!(code.contains("(\"users\", \"0001_initial\")"));
        assert!(code.contains("MigrationOperation::AddColumn"));
    }

    #[test]
    fn test_column_with_default() {
        let writer = MigrationWriter::new("users", "0003_add_active").operation(
            MigrationOperation::add_column(
                "users",
                ColumnSchema::new("is_active", SqlType::Boolean)
                    .not_null()
                    .default(DefaultValue::Bool(true)),
            ),
        );

        let code = writer.generate();

        assert!(code.contains("SqlType::Boolean"));
        assert!(code.contains(".not_null()"));
        assert!(code.contains("DefaultValue::Bool(true)"));
    }
}
