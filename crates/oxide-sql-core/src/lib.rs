//! # oxide-sql-core
//!
//! A type-safe SQL parser and builder with compile-time validation.
//!
//! This crate provides:
//! - A hand-written recursive descent parser with Pratt expression parsing
//! - Type-safe SQL builders using the typestate pattern
//! - Protection against SQL injection through parameterized queries
//! - A type-safe migrations system (Django-like)
//!
//! ## Type-Safe SQL Building (Recommended)
//!
//! Use `Select`, `Insert`, `Update`, `Delete` with `#[derive(Table)]` for
//! compile-time validated queries:
//!
//! ```rust
//! use oxide_sql_core::builder::Select;
//! use oxide_sql_core::schema::Table;
//!
//! // Schema types (normally generated by #[derive(Table)] from oxide-sql-derive)
//! struct User { id: i32, name: String, active: bool }
//! struct UserTable;
//!
//! impl Table for UserTable {
//!     type Row = User;
//!     const NAME: &'static str = "users";
//!     const COLUMNS: &'static [&'static str] = &["id", "name", "active"];
//!     const PRIMARY_KEY: Option<&'static str> = Some("id");
//! }
//!
//! // Compile-time validated query - invalid columns won't compile
//! let (sql, params) = Select::<UserTable, _, _>::new()
//!     .select_all()
//!     .from_table()
//!     .build();
//!
//! assert_eq!(sql, "SELECT id, name, active FROM users");
//! ```
//!
//! ## Dynamic SQL Building
//!
//! For string-based queries without compile-time validation, use `SelectDyn`,
//! `InsertDyn`, `UpdateDyn`, `DeleteDyn` with `dyn_col`:
//!
//! ```rust
//! use oxide_sql_core::builder::{SelectDyn, dyn_col};
//!
//! let (sql, params) = SelectDyn::new()
//!     .columns(&["id", "name"])
//!     .from("users")
//!     .where_clause(dyn_col("active").eq(true))
//!     .build();
//!
//! assert_eq!(sql, "SELECT id, name FROM users WHERE active = ?");
//! ```
//!
//! ## SQL Injection Prevention
//!
//! All values are automatically parameterized:
//!
//! ```rust
//! use oxide_sql_core::builder::{SelectDyn, dyn_col};
//!
//! let user_input = "'; DROP TABLE users; --";
//! let (sql, params) = SelectDyn::new()
//!     .columns(&["id"])
//!     .from("users")
//!     .where_clause(dyn_col("name").eq(user_input))
//!     .build();
//!
//! // sql = "SELECT id FROM users WHERE name = ?"
//! // The malicious input is safely parameterized
//! assert_eq!(sql, "SELECT id FROM users WHERE name = ?");
//! ```
//!
//! ## Type-Safe Migrations
//!
//! The migrations module provides Django-like database migrations with compile-time
//! validation:
//!
//! ```rust
//! use oxide_sql_core::migrations::{
//!     Migration, Operation, CreateTableBuilder,
//!     bigint, varchar, timestamp,
//! };
//!
//! pub struct Migration0001;
//!
//! impl Migration for Migration0001 {
//!     const ID: &'static str = "0001_create_users";
//!
//!     fn up() -> Vec<Operation> {
//!         vec![
//!             CreateTableBuilder::new()
//!                 .name("users")
//!                 .column(bigint("id").primary_key().autoincrement().build())
//!                 .column(varchar("username", 255).not_null().unique().build())
//!                 .column(timestamp("created_at").not_null().default_expr("CURRENT_TIMESTAMP").build())
//!                 .build()
//!                 .into(),
//!         ]
//!     }
//!
//!     fn down() -> Vec<Operation> {
//!         vec![Operation::drop_table("users")]
//!     }
//! }
//! ```

pub mod ast;
pub mod builder;
pub mod dialect;
pub mod lexer;
pub mod migrations;
pub mod parser;
pub mod schema;

pub use ast::{Expr, Statement};
pub use builder::{
    col, dyn_col, Delete, DeleteDyn, Insert, InsertDyn, Select, SelectDyn, Update, UpdateDyn,
};
pub use lexer::{Lexer, Token, TokenKind};
pub use parser::{ParseError, Parser};
pub use schema::{Column, Selectable, Table, TypedColumn};
